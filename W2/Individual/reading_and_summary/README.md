<!-- # 隨堂小測驗（投影片第 24 頁） -->
<!-- - 列出題目與你的回答和說明 -->
<!-- # [閱讀 ethereum white paper](https://ethereum.org/en/whitepaper/) -->
<!-- - 寫下簡易筆記／心得 -->

# week2 hw

## * 隨堂小測驗

Q1: Account public key 就是 account address? \
A1: No，Account public key 不為 account address
```
帳戶建立會同時產生三個元素：私鑰、公鑰、位址
彼此之間是有關聯的，建立完成後，值就無法再更改。

私鑰 (Account Private Key)：32 個字，16 進位數字，用來發送交易和簽名。
公鑰 (Account Public Key)：64 個字，用來驗證交易的真假。
位址 (Account Address)：你可以將位址告訴別人，讓他照這個地址轉以太幣給你。

資料來源：https://ithelp.ithome.com.tw/articles/10200900
```

Q2: Transaction 的順序是依照時間順序來決定的？ \
A2: Yes，一般是依照時間順序，但若是希望交易快一點被確認，也可以透過提高 gas price 使交易順序提前 
```
等待中的交易(pending_pranscations)：當使用者發送交易時，因為區塊鏈能夠吞吐的交易量有限，交易會先處在pending的狀況，當交易量過大時，礦工會首先選擇手續費高的交易先處理。

1.交易送出後會被丟到一個「交易池」中等待被礦工打包，決定先後順序的主要因子為「單位 Gas Price（GWEI）」給的多寡。
2.發送交易時可以到 ETH gas station 參考即時的「交易池」狀況再來決定要設多少 GWEI 以能在預期的時間內被打包上鏈。
3.若發現交易持續滯留在「交易池」中等待被處理，可以「加速交易」或「取消交易」。

資料來源：
https://www.ithome.com.tw/news/105373
https://ithelp.ithome.com.tw/articles/10215081
https://www.blocktempo.com/understand-ethereum-transaction/
```

Q3: Transaction 不是成功就是失敗，不會有執行到一半就中斷的情況發生？ \
A3: （＊）Yes
```
A transaction is an atomic operation . Can't divide or interrupt.
That is, All (complete done) or Nothing (zero effect).

資料來源：上課ppt.15
```

Q4: 簡短說明 EOA 和 contract account 的差別？ \
A4: Contract Account 比 EOA 增加了 Storage hash 以及 Code hash 的欄位，而 Contract 只能是交易的中繼者，EOA 能夠作為交易的發起者。

Q5: 簡短說明什麼是 Transaction pool \
A5: 交易送出後會被丟到一個「交易池 Transaction pool」中等待被礦工打包，此時的交易狀態是未確認的pending狀態。

Q6: Gas price 是如何被計算出來的？ \
A6: Gas Price = Base fee + Priority fee

```
2021 年 8 月 倫敦升級之後，
手續費的規則改為鏈訂價的 base fee 加上給礦工的 priority fee。

使用者要設定兩個 max。
=> max fee 是使用者願意對每一單位 gas 最多付出多少 Gwei
=> max priority 使用者願意對每一單位 gas 給礦工多少 Gwei 。

這兩個值一般錢包軟體會幫使用者設定，但使用者可以自訂。
理解哪些值是哪些角色決定的有助於避免混淆那個值的意義，
所以即使錢包軟體會幫你設定，還是要當成是使用者設定的，
錢包只是輔助執行使用者的意志。

資料來源：https://medium.com/taipei-ethereum-meetup/eip-1559-tx-fee-232576cc11dc
```

Q7: 是什麼促使 state 發生改變？ \
A7:（＊）有交易發生，就會造成 state 的改變

（不太確定是否理解錯問題中的 state）
```
區塊鏈想做的，便是一個分散式的系統，這個系統紀錄了一個Global State，並且透過一個共識協議不斷更新，而這個State是全世界節點都能夠達成共識的。

可以將State看成一個對時間的函數：S(t) 指的是在t時間點區塊鏈的狀態，而S(t+1)就是下一秒的區塊鏈狀態。在許多討論中，也常常是以「每一筆交易」為單位在描述State：一個狀態S[i]在發生了任一個交易TX[i]之後，整個區塊鏈的狀態也會有些改變，成為S[i+1]：S[i+1] = APPLY(S[i],TX[i])，會這麼表示是為了要表達一個節點在驗證一個區塊時，需要一筆交易一筆交易去改變State。

資料來源：
https://steemit.com/da-chaintalk/@deanliu/state
https://medium.com/taipei-ethereum-meetup/optimistic-rollup-%E7%9A%84%E6%8C%91%E6%88%B0%E6%A9%9F%E5%88%B6-%E4%BA%8C-optimism-ovm-2-0-4420e5adc734
http://yangzhe.me/2019/06/19/ethereum-state/
https://ethereum.stackexchange.com/questions/58535/understanding-the-state-transition-function
```

Q8: Full node 和 light node有什麼區別？ \
A8: 全節點儲存了所有區塊的 Block Header 與 Body（交易列表），而輕節點只儲存最小量的狀態，即區塊標頭 Block Header。



## * ethereum white paper

[英文版本](https://ethereum.org/en/whitepaper/) /
[中文翻譯](https://cypherpunks-core.github.io/products/EthereumWhitePaper/)


摘要：


History
-

=> 中本聰引入這樣一個理念：將一個非常簡單的基於節點的去中心化共識協議與工作量證明機制結合在一起。
節點通過工作量證明機制獲得參與到系統的權利，每十分鐘將交易打包到"區塊"中，從而創建出不斷增長的區塊鏈。
擁有大量算力的節點有更大的影響力。

---

Mining
-

=> 我們想把比特幣系統建成為去中心化的貨幣系統，為了確保每個人都同意交易的順序，我們需要將狀態轉換系統與一個共識系統結合起來。
設計為大約每十分鐘產生一個區塊，每個區塊包含一個時間戳、一個隨機數、一個對上一個區塊的引用（即雜湊）和上一區塊生成以來發生的所有交易列表。
這樣隨著時間流逝就創建出了一個持續增長的區塊鏈，它不斷地更新，從而能夠代表比特幣賬本的最新狀態。

依照這個正規化，檢查一個區塊是否有效的演算法如下：
- 檢查區塊引用的上一個區塊是否存在且有效。
- 檢查區塊的時間戳是否晚於以前的區塊的時間戳，而且早於未來2小時。
- 檢查區塊的工作量證明是否有效。
- 將上一個區塊的最終狀態賦於 S[0] 。
- 假設TX是區塊的交易列表，包含n筆交易。對於屬於0……n-1的所有i,進行狀態轉換 S[i+1] = APPLY(S[i],TX[i]) 。如果任何一筆交易i在狀態轉換中出錯，退出程式，返回錯誤。
- 返回正確，狀態 S[n] 是這一區塊的最終狀態。

=> 區塊驗證演算法的有趣部分是"工作量證明"概念：對每個區塊進行SHA256雜湊處理，將得到的雜湊視為長度為256位元的數值，該數值必須小於不斷動態調整的目標數值，本書寫作時目標數值大約是2^190。
工作量證明的目的是使區塊的建立變得困難，從而阻止女巫攻擊者惡意重新生成區塊鏈。
因為SHA256是完全不可預測的偽隨機函數，建立有效區塊的唯一方法就是簡單地不斷試錯，不斷地增加隨機數的數值，檢視新的雜湊數值是否小於目標數值。
如果當前的目標數值是2^192，就意味著平均需要嘗試2^64次才能生成有效的區塊。
一般而言，比特幣網路每隔2016個區塊重新設定目標數值，保證平均每十分鐘生成一個區塊。
為了對礦工的計算工作進行獎勵，每一個成功生成區塊的礦工有權在區塊中包含一筆憑空發給他們自己25BTC的交易。
另外，如果交易的輸入大於輸出，差額部分就作為"交易費用"付給礦工。

=> 分析比特幣網路出現惡意攻擊者時會發生什麼。
因為比特幣的密碼學基礎是非常安全的，所以攻擊者會選擇攻擊沒有被密碼學直接保護的部分：交易順序。

攻擊者的策略非常簡單：
- 向賣家傳送100BTC購買商品（尤其是無需郵寄的電子商品）。
- 等待直至商品發出。
- 建立另一筆交易，將相同的100BTC傳送給自己的賬戶。
- 使比特幣網路相信傳送給自己賬戶的交易是最先發出的。

=> 比特幣系統的一個重要的可擴充套件特性是：它的交易儲存在多層次的資料結構中。
一個區塊的雜湊實際上只是區塊頭的雜湊，區塊頭是包含時間戳、隨機數、上個區塊雜湊和儲存了所有的區塊交易的默克爾樹的根雜湊的長度大約為200位元組的一段資料。

---

Merkle Trees
-

=> 默克爾樹是一種二叉樹，由一組葉節點、一組中間節點和一個根節點構成。
最下面的大量的葉節點包含基礎資料，每個中間節點是它的兩個子節點的雜湊，根節點也是由它的兩個子節點的雜湊，代表了默克爾樹的頂部。默克爾樹的目的是允許區塊的資料可以零散地傳送：節點可以從一個源下載區塊頭，從另外的源下載與其有關的樹的其它部分，而依然能夠確認所有的資料都是正確的。
之所以如此是因為雜湊向上的擴散：如果一個惡意使用者嘗試在樹的下部加入一個偽造的交易，所引起的改動將導致樹的上層節點的改動，以及更上層節點的改動，最終導致根節點的改動以及區塊雜湊的改動，這樣協議就會將其記錄為一個完全不同的區塊（幾乎可以肯定是帶著不正確的工作量證明的）。

默克爾樹協議對比特幣的長期持續性可以說是至關重要的。
在2014年4月，比特幣網路中的一個全節點-儲存和處理所有區塊的全部資料的節點-需要佔用15GB的記憶體空間，而且還以每個月超過1GB的速度增長。
目前，這一儲存空間對臺式計算機來說尚可接受，但是手機已經負載不了如此巨大的資料了。
未來只有商業機構和愛好者才會充當完整節點。簡化支付確認（SPV）協議允許另一種節點存在，這樣的節點被成為"輕節點"，它下載區塊頭，使用區塊頭確認工作量證明，然後只下載與其交易相關的默克爾樹"分支"。
這使得輕節點只要下載整個區塊鏈的一小部分就可以安全地確定任何一筆比特幣交易的狀態和賬戶的當前餘額。

---

Scripting
-

=> 基本的公鑰所有權機制也是通過指令碼實現的：指令碼將橢圓曲線簽名作為輸入，驗證交易和擁有這一UTXO的地址，如果驗證成功，返回1，否則返回0。更加複雜的指令碼用於其它不同的應用情況。例如，人們可以建立要求集齊三把私鑰中的兩把才能進行交易確認的指令碼（多重簽名），對公司賬戶、儲蓄賬戶和某些商業代理來說，這種指令碼是非常有用的。指令碼也能用來對解決計算問題的使用者傳送獎勵。人們甚至可以建立這樣的指令碼"如果你能夠提供你已經發送一定數額的的狗幣給我的簡化確認支付證明，這一比特幣UTXO就是你的了"，本質上，比特幣系統允許不同的密碼學貨幣進行去中心化的兌換。

比特幣系統的指令碼語言存在一些嚴重的限制：

- 缺少圖靈完備性 - 這就是說，儘管比特幣指令碼語言可以支援多種計算，但是它不能支援所有的計算。最主要的缺失是迴圈語句。不支援迴圈語句的目的是避免交易確認時出現無限迴圈。理論上，對於指令碼程式設計師來說，這是可以克服的障礙，因為任何迴圈都可以用多次重複if 語句的方式來模擬，但是這樣做會導致指令碼空間利用上的低效率，例如，實施一個替代的橢圓曲線簽名演算法可能將需要256次重複的乘法，而每次都需要單獨編碼。
- 價值盲（Value-blindness）。UTXO指令碼不能為賬戶的取款額度提供精細的的控制。例如，預言機合約（oracle contract）的一個強大應用是對衝合約，A和B各自向對衝合約中傳送價值1000美元的比特幣，30天以後，指令碼向A傳送價值1000美元的比特幣，向B傳送剩餘的比特幣。雖然實現對衝合約需要一個預言機（oracle）決定一比特幣值多少美元，但是與現在完全中心化的解決方案相比，這一機制已經在減少信任和基礎設施方面有了巨大的進步。然而，因為UTXO是不可分割的，為實現此合約，唯一的方法是非常低效地採用許多有不同面值的UTXO（例如對應於最大為30的每個k，有一個2^k的UTXO）並使預言機挑出正確的UTXO傳送給A和B。
- 缺少狀態 - UTXO只能是已花費或者未花費狀態，這就沒有給需要任何其它內部狀態的多階段合約或者指令碼留出生存空間。這使得實現多階段期權合約、去中心化的交換要約或者兩階段加密承諾協議（對確保計算獎勵非常必要）非常困難。這也意味著UTXO只能用於建立簡單的、一次性的合約，而不是例如去中心化組織這樣的有著更加複雜的狀態的合約，使得元協議難以實現。二元狀態與價值盲結合在一起意味著另一個重要的應用-取款限額-是不可能實現的。
- 區塊鏈盲（Blockchain-blindness）- UTXO看不到區塊鏈的資料，例如隨機數和上一個區塊的雜湊。這一缺陷剝奪了指令碼語言所擁有的基於隨機性的潛在價值，嚴重地限制了博彩等其它領域應用。


---

Ethereum
-

=> 以太坊的目的是基於指令碼、競爭幣和鏈上元協議（on-chain meta-protocol）概念進行整合和提高，使得開發者能夠建立任意的基於共識的、可擴充套件的、標準化的、特性完備的、易於開發的和協同的應用。
以太坊通過建立終極的抽象的基礎層-內建有圖靈完備程式語言的區塊鏈-使得任何人都能夠建立合約和去中心化應用並在其中設立他們自由定義的所有權規則、交易方式和狀態轉換函數。
智慧合約-包含價值而且只有滿足某些條件才能開啟的加密箱子-也能在我們的平臺上建立，並且因為圖靈完備性、價值知曉（value-awareness）、區塊鏈知曉（blockchain-awareness）和多狀態所增加的力量而比比特幣指令碼所能提供的智慧合約強大得多。

---

Ethereum Accounts
-

在以太坊系統中，狀態是由被稱為"賬戶"（每個賬戶由一個20位元組的地址）的物件和在兩個賬戶之間轉移價值和資訊的狀態轉換構成的。以太坊的賬戶包含四個部分：
- The nonce, a counter used to make sure each transaction can only be processed once 隨機數，用於確定每筆交易只能被處理一次的計數器
- The account's current ether balance 賬戶目前的以太幣餘額
- The account's contract code, if present 賬戶的合約程式碼，如果有的話
- The account's storage (empty by default) 賬戶的儲存（預設為空）

=> 以太幣（Ether）是以太坊內部的主要加密燃料，用於支付交易費用。一般而言，以太坊有兩種類型的賬戶：外部所有的賬戶（由私鑰控制的）和合約賬戶（由合約程式碼控制）。
外部所有的賬戶沒有程式碼，人們可以通過建立和簽名一筆交易從一個外部賬戶傳送訊息。
每當合約賬戶收到一條訊息，合約內部的程式碼就會被啟用，允許它對內部儲存進行讀取和寫入，和傳送其它訊息或者建立合約。

---

Messages and Transactions
-

以太坊的訊息在某種程度上類似於比特幣的交易，但是兩者之間存在三點重要的不同。
- 第一，以太坊的訊息可以由外部實體或者合約建立，然而比特幣的交易只能從外部建立。
- 第二，以太坊訊息可以選擇包含資料。
- 第三，如果以太坊訊息的接受者是合約賬戶，可以選擇進行迴應，這意味著以太坊訊息也包含函數概念。

=> 以太坊中"交易"是指儲存從外部賬戶發出的訊息的簽名資料包。
交易包含訊息的接收者、用於確認傳送者的簽名、以太幣賬戶餘額、要傳送的資料和兩個被稱為STARTGAS和GASPRICE的數值。
為了防止程式碼的指數型爆炸和無限迴圈，每筆交易需要對執行程式碼所引發的計算步驟-包括初始訊息和所有執行中引發的訊息-做出限制。
STARTGAS就是限制，GASPRICE是每一計算步驟需要支付礦工的費用。
如果執行交易的過程中，"用完了瓦斯"，所有的狀態改變恢復原狀態，但是已經支付的交易費用不可收回了。
如果執行交易中止時還剩餘瓦斯，那麼這些瓦斯將退還給傳送者。
建立合約有單獨的交易類型和相應的訊息類型；合約的地址是基於賬號隨機數和交易資料的雜湊計算出來的。

---

Ethereum State Transition Function
-


以太坊的狀態轉換函數： APPLY(S,TX) -> S' ，可以定義如下：

- 檢查交易的格式是否正確（即有正確數值）、簽名是否有效和隨機數是否與傳送者賬戶的隨機數匹配。如否，返回錯誤。
- 計算交易費用: fee=STARTGAS * GASPRICE ，並從簽名中確定傳送者的地址。從傳送者的賬戶中減去交易費用和增加發送者的隨機數。如果賬戶餘額不足，返回錯誤。
- 設定初值 GAS = STARTGAS ，並根據交易中的位元組數減去一定量的瓦斯值。
- 從傳送者的賬戶轉移價值到接收者賬戶。如果接收賬戶還不存在，建立此賬戶。如果接收賬戶是一個合約，執行合約的程式碼，直到程式碼執行結束或者瓦斯用完。
- 如果因為傳送者賬戶沒有足夠的錢或者程式碼執行耗盡瓦斯導致價值轉移失敗，恢復原來的狀態，但是還需要支付交易費用，交易費用加至礦工賬戶。
- 否則，將所有剩餘的瓦斯歸還給傳送者，消耗掉的瓦斯作為交易費用傳送給礦工。 例如，假設合約的程式碼如下：python if not self.storage[calldataload(0)]: self.storage[calldataload(0)] = calldataload(32)

---

Code Execution
-

- 堆棧，一種後進先出的資料儲存，32位元組的數值可以入棧，出棧。
- 記憶體，可無限擴充套件的位元組佇列。
- 合約的長期儲存，一個祕鑰/數值的儲存，其中祕鑰和數值都是32位元組大小，與計算結束即重置的堆棧和記憶體不同，儲存內容將長期保持。



---

Further Applications
-

- Savings wallets
- Crop insurance
- A decentralized data feed
- Smart multisignature escrow
- Cloud computing
- Peer-to-peer gambling
- Prediction markets
- On-chain decentralized marketplaces

---

Conclusion
-

=> 以太坊協議最初是作為一個通過高度通用的語言提供如鏈上契約，提現限制和金融合約，賭博市場等高階功能的升級版密碼學貨幣來構思的。以太坊協議將不直接"支援"任何應用，但圖靈完備程式語言的存在意味著理論上任意的合約都可以為任何交易類型和應用創建出來。然而關於以太坊更有趣的是，以太坊協議比單純的貨幣走得更遠，圍繞去中心化儲存，去中心化計算和去中心化預測市場以及數十個類似概念建立的協議和去中心化應用，有潛力從根本上提升計算行業的效率，並通過首次新增經濟層為其它的P2P協議提供有力支撐，最終，同樣會有大批與金錢毫無關係的應用出現。

以太坊協議實現的任意狀態轉換概念提供了一個具有獨特潛力的平臺；與封閉式的，為諸如資料儲存，賭博或金融等單一目的設計的協議不同，以太坊從設計上是開放式的，並且我們相信它極其適合作為基礎層服務於在將來的年份裡出現的極其大量的金融和非金融協議。

---

心得：

從市場先生的文章中得知的幾個關於白皮書的重點整理：

1. 加密貨幣白皮書是在虛擬貨幣要上市(ICO)前，提供項目執行內容、目標願景的一份報告，閱讀白皮書讓投資者對這個項目更深入瞭解，在各加密貨幣官網，都能下載白皮書來閱讀。
2. 投資虛擬貨幣前，建議要閱讀白皮書。一份好的白皮書應該要明確列出基於證據的市場研究、風險分析、安全性，也要讓投資人容易理解該項目所擁有的價值、它要解決的問題是什麼。
3. 加密貨幣的6大閱讀重點包括：執行的項目內容、該如何運作、為什麼需要這個項目、團隊組成、為什麼需要運行在區塊鏈上、虛擬貨幣如何使用。
4. 閱讀白皮書時有3點可以是否有隱藏詐騙陷阱：
   
    - 網路搜尋檢查白皮書中是否有抄襲 
    - 內容是否回答了你所有的問題，還是留下了太多未回答的問題 
    - 內容多描述在願景上，還是多描述項目的解決方式與執行方式。

要懂一個虛擬貨幣，讀白皮書是一個很好的入門方式，因為時間有限，這次我先略讀中文版的白皮書，有時間再補齊英文版本。光略讀，就能發現很多外面的文章知識是來自這裡，而對我來說收穫最多的地方是了解更多的應用和原理。
